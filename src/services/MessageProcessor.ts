import { WahaService } from './WahaService';
import { OpenAIService } from './OpenAIService';
import { HumanDelay } from './HumanDelay';
import { CustomerMemoryDB } from './CustomerMemoryDB';
import { UserEngagementAnalyzer } from './UserEngagementAnalyzer';
import { SentimentAnalyzer } from './SentimentAnalyzer';
import { ContextAwareness } from './ContextAwareness';
import { HumanImperfectionEngine } from './HumanImperfectionEngine';
import { SmartResponseSplitter } from './SmartResponseSplitter';
import { ConversionOptimizer } from './ConversionOptimizer';
import { FollowUpManager } from './FollowUpManager';
import { AudioTranscriptionService } from './AudioTranscriptionService';
import { InformationExtractor } from './InformationExtractor';
import { MessageBuffer } from './MessageBuffer';
import { ReactionDecider } from './ReactionDecider';
import { QuoteAnalyzer } from './QuoteAnalyzer';
import { PetPhotoAnalyzer } from './PetPhotoAnalyzer';
import { PersonalityDetector } from './PersonalityDetector';
import { PersonalityProfiler } from './PersonalityProfiler';
import { EmotionalIntelligence } from './EmotionalIntelligence';
import { ConversationFlowOptimizer } from './ConversationFlowOptimizer';
import { MessageAuditor } from './MessageAuditor';
import { ImmediateFollowUpManager } from './ImmediateFollowUpManager';
import { PixDiscountManager } from './PixDiscountManager';
import { ContextRetrievalService } from './ContextRetrievalService';
import { OnboardingManager } from './OnboardingManager';
import { IntentAnalyzer, CustomerIntent } from './IntentAnalyzer';
import { PETSHOP_CONFIG, getServicosDescricao, getHorarioDescricao } from '../config/petshop.config';
import { PersonalizedGreeting } from './PersonalizedGreeting';
import { ProofSocialEngine } from './ProofSocialEngine';
import { getQualityTracker, ResponseQualityData } from './ResponseQualityTracker';
import { getEmotionalPersistence } from './EmotionalContextPersistence';
import { ResponseRelevanceValidator } from './ResponseRelevanceValidator';
import { ConversationStateManager } from './ConversationStateManager';
// üÜï SPRINT 1: Sistema de Agendamentos
import { AppointmentManager } from './AppointmentManager';
import { AvailabilityManager } from './AvailabilityManager';
import { ServiceKnowledgeManager } from './ServiceKnowledgeManager';
import { CompanyConfigManager } from './CompanyConfigManager';
import { CancellationRecoveryManager } from './CancellationRecoveryManager';
import { EnhancedReminderManager } from './EnhancedReminderManager';
import { Pool } from 'pg';

/**
 * C√âREBRO DO SISTEMA: Orquestra TODOS os m√≥dulos de IA comportamental
 * Processador de mensagens ULTRA-HUMANIZADO
 */
export class MessageProcessor {
  private processingMessages: Set<string>;
  private lastMessageTimestamps: Map<string, number>; // Track timestamps por chat

  // M√≥dulos de an√°lise
  private engagementAnalyzer: UserEngagementAnalyzer;
  private sentimentAnalyzer: SentimentAnalyzer;
  private contextAwareness: ContextAwareness;
  private informationExtractor: InformationExtractor;

  // üÜï NOVOS: M√≥dulos de an√°lise psicol√≥gica
  private personalityDetector: PersonalityDetector;
  private personalityProfiler: PersonalityProfiler;
  private emotionalIntelligence: EmotionalIntelligence;
  private flowOptimizer: ConversationFlowOptimizer;

  // M√≥dulos de humaniza√ß√£o
  private imperfectionEngine: HumanImperfectionEngine;
  private responseSplitter: SmartResponseSplitter;
  private reactionDecider: ReactionDecider;
  private quoteAnalyzer: QuoteAnalyzer;

  // M√≥dulos de convers√£o
  private conversionOptimizer: ConversionOptimizer;
  private followUpManager: FollowUpManager;
  private immediateFollowUpManager: ImmediateFollowUpManager;

  // M√≥dulo de transcri√ß√£o de √°udio
  private audioService: AudioTranscriptionService;

  // M√≥dulo de an√°lise de fotos
  private photoAnalyzer: PetPhotoAnalyzer;

  // M√≥dulo de buffer de mensagens (concatena√ß√£o)
  private messageBuffer: MessageBuffer;

  // üí≥ M√≥dulo de pagamentos PIX (opcional)
  private pixDiscountManager?: PixDiscountManager;

  // üÜï M√≥dulos de contexto e onboarding
  private contextRetrieval?: ContextRetrievalService;
  private onboardingManager?: OnboardingManager;
  private intentAnalyzer?: IntentAnalyzer;

  // ‚ö° NOVOS: Sprint 1 Quick Wins
  private personalizedGreeting: PersonalizedGreeting;
  private proofSocialEngine: ProofSocialEngine;

  // üí¨ Gerenciador de estado de conversas (evita InstantAck duplicado)
  private conversationState: ConversationStateManager;

  // üÜï SPRINT 1: M√≥dulos de agendamento
  private appointmentManager?: AppointmentManager;
  private availabilityManager?: AvailabilityManager;
  private serviceKnowledge?: ServiceKnowledgeManager;
  private companyConfig?: CompanyConfigManager;
  private cancellationRecovery?: CancellationRecoveryManager;
  private enhancedReminders?: EnhancedReminderManager;

  constructor(
    private wahaService: WahaService,
    private openaiService: OpenAIService,
    private humanDelay: HumanDelay,
    private memoryDB: CustomerMemoryDB,
    private audioTranscription: AudioTranscriptionService,
    private openaiApiKey: string,
    conversationState: ConversationStateManager,
    pixDiscountManager?: PixDiscountManager,
    contextRetrieval?: ContextRetrievalService,
    onboardingManager?: OnboardingManager,
    intentAnalyzer?: IntentAnalyzer,
    db?: Pool
  ) {
    this.conversationState = conversationState;
    this.processingMessages = new Set();
    this.lastMessageTimestamps = new Map();

    // Inicializa todos os m√≥dulos
    this.engagementAnalyzer = new UserEngagementAnalyzer();
    this.sentimentAnalyzer = new SentimentAnalyzer();
    this.contextAwareness = new ContextAwareness();
    this.informationExtractor = new InformationExtractor();
    this.imperfectionEngine = new HumanImperfectionEngine();
    this.responseSplitter = new SmartResponseSplitter();
    this.reactionDecider = new ReactionDecider();
    this.quoteAnalyzer = new QuoteAnalyzer();
    this.conversionOptimizer = new ConversionOptimizer();
    this.followUpManager = new FollowUpManager(memoryDB);
    this.immediateFollowUpManager = new ImmediateFollowUpManager(wahaService, memoryDB);
    this.audioService = audioTranscription;
    this.photoAnalyzer = new PetPhotoAnalyzer(openaiApiKey);
    this.messageBuffer = new MessageBuffer();

    // üÜï NOVOS: M√≥dulos de an√°lise psicol√≥gica
    this.personalityDetector = new PersonalityDetector();
    this.personalityProfiler = new PersonalityProfiler();
    this.emotionalIntelligence = new EmotionalIntelligence();
    this.flowOptimizer = new ConversationFlowOptimizer();

    // üí≥ Pagamentos PIX (se configurado)
    this.pixDiscountManager = pixDiscountManager;
    if (this.pixDiscountManager) {
      console.log('üí≥ Pagamentos PIX habilitados no MessageProcessor');
    }

    // üÜï Contexto e Onboarding
    this.contextRetrieval = contextRetrieval;
    this.onboardingManager = onboardingManager;
    this.intentAnalyzer = intentAnalyzer;
    if (this.contextRetrieval && this.onboardingManager && this.intentAnalyzer) {
      console.log('üß† Contexto cont√≠nuo e onboarding habilitados!');
    }

    // ‚ö° SPRINT 1: Quick Wins
    this.personalizedGreeting = new PersonalizedGreeting();
    this.proofSocialEngine = new ProofSocialEngine(wahaService);
    console.log('‚ö° Sprint 1 Quick Wins habilitados (sauda√ß√£o + prova social)!');

    // üÜï SPRINT 1: Sistema de Agendamentos
    if (db) {
      this.appointmentManager = new AppointmentManager(db);
      this.availabilityManager = new AvailabilityManager(db);
      this.serviceKnowledge = new ServiceKnowledgeManager(db);
      this.companyConfig = new CompanyConfigManager(db);
      this.cancellationRecovery = new CancellationRecoveryManager(
        wahaService,
        this.appointmentManager,
        this.availabilityManager
      );
      this.enhancedReminders = new EnhancedReminderManager(db, wahaService);
      console.log('üìÖ Sistema de Agendamentos completo inicializado!');
    }

    console.log('üß† MessageProcessor ULTRA-HUMANIZADO com An√°lise Psicol√≥gica inicializado!');
  }

  private shouldProcessMessage(message: any): boolean {
    if (message.fromMe) {
      console.log('‚è≠Ô∏è Ignorando mensagem pr√≥pria');
      return false;
    }

    if (message.from?.includes('@g.us')) {
      console.log('‚è≠Ô∏è Ignorando mensagem de grupo');
      return false;
    }

    if (message.from?.includes('status@broadcast')) {
      console.log('‚è≠Ô∏è Ignorando mensagem de status');
      return false;
    }

    // Permite mensagens de √°udio mesmo sem body
    const isAudio = this.audioService.isAudioMessage(message);
    if (!isAudio && (!message.body || message.body.trim() === '')) {
      console.log('‚è≠Ô∏è Ignorando mensagem sem texto');
      return false;
    }

    const messageId = `${message.from}-${message.timestamp}`;
    if (this.processingMessages.has(messageId)) {
      console.log('‚è≠Ô∏è Mensagem j√° est√° sendo processada');
      return false;
    }

    return true;
  }

  /**
   * NOVO: Processa mensagem com AN√ÅLISE COMPORTAMENTAL COMPLETA
   * Usa MessageBuffer para concatenar mensagens enviadas em sequ√™ncia
   */
  public async processMessage(message: any): Promise<void> {
    try {
      if (!this.shouldProcessMessage(message)) return;

      const chatId = message.from;
      const isAudio = this.audioService.isAudioMessage(message);

      // Se for √°udio, processa imediatamente (n√£o concatena)
      if (isAudio) {
        await this.processMessageInternal(message);
        return;
      }

      // Para mensagens de texto, usa buffer (concatena√ß√£o)
      await this.messageBuffer.addMessage(chatId, message, async (concatenatedBody, lastMessage) => {
        // Sobrescreve body da √∫ltima mensagem com concatena√ß√£o
        lastMessage.body = concatenatedBody;
        await this.processMessageInternal(lastMessage);
      });
    } catch (error) {
      console.error('‚ùå Erro ao processar mensagem:', error);
    }
  }

  /**
   * Processamento interno da mensagem (ap√≥s concatena√ß√£o se necess√°rio)
   */
  private async processMessageInternal(message: any): Promise<void> {
    const startTime = Date.now(); // Para medir tempo de resposta

    try {
      const chatId = message.from;
      let body = message.body;
      const messageId = `${chatId}-${message.timestamp}`;
      const now = Date.now();

      this.processingMessages.add(messageId);

      // üéôÔ∏è PROCESSA √ÅUDIO SE NECESS√ÅRIO
      const isAudio = this.audioService.isAudioMessage(message);
      if (isAudio) {
        console.log('\nüéôÔ∏è ========================================');
        console.log('üéôÔ∏è √ÅUDIO DETECTADO - INICIANDO TRANSCRI√á√ÉO');
        console.log('üéôÔ∏è ========================================\n');

        try {
          // Envia resposta humanizada ANTES de transcrever (conex√£o genu√≠na!)
          const acknowledgment = this.audioService.getAudioAcknowledgment();
          await this.wahaService.sendMessage(chatId, acknowledgment);
          console.log(`üí¨ Marina: "${acknowledgment}"`);

          // Pega URL do √°udio
          const audioUrl = this.audioService.getAudioUrl(message);
          if (!audioUrl) {
            throw new Error('URL do √°udio n√£o encontrada');
          }

          // Transcreve o √°udio
          body = await this.audioService.transcribeAudio(audioUrl, messageId);
          console.log(`‚úÖ √Åudio transcrito: "${body.substring(0, 100)}..."`);
        } catch (error: any) {
          console.error(`‚ùå Erro ao processar √°udio: ${error.message}`);
          await this.wahaService.sendMessage(chatId, 'nao consegui ouvir direito, pode repetir?');
          this.processingMessages.delete(messageId);
          return;
        }
      }

      console.log('\nüß† ========================================');
      console.log(`üß† PROCESSAMENTO COMPORTAMENTAL INICIADO`);
      console.log(`üì® Chat: ${chatId}`);
      console.log(`üì® Mensagem: "${body}"`);
      console.log('üß† ========================================\n');

      // üö¶ RATE LIMITING - Protege contra spam (20 msgs/minuto)
      const allowed = await (await import('./RedisClient')).redisClient.checkRateLimit(
        `chat:${chatId}`,
        20,  // m√°ximo 20 mensagens
        60   // por minuto
      );

      if (!allowed) {
        console.log(`‚ö†Ô∏è RATE LIMIT excedido: ${chatId} (>20 msgs/min)`);
        await this.wahaService.sendMessage(
          chatId,
          'opa! calma ai üòÖ\n' +
          'muitas mensagens em sequ√™ncia\n' +
          'aguarda 1 minutinho pra eu processar tudo direitinho'
        );
        this.processingMessages.delete(messageId);
        return;
      }

      // üî• CLIENTE RESPONDEU - Cancela follow-ups se houver
      // üß† NOVO: Passa mensagem para detectar irrita√ß√£o
      this.immediateFollowUpManager.onClientMessage(chatId, body);

      // üü¢ DEFINE PRESEN√áA COMO ONLINE
      await this.wahaService.setPresence(chatId, true);

      // 1Ô∏è‚É£ CARREGA/CRIA PERFIL DO USU√ÅRIO
      const profile = await this.memoryDB.getOrCreateProfile(chatId);
      console.log(`üë§ Perfil carregado: ${profile.nome || 'novo cliente'}`);

      // üÜï 1.0.5Ô∏è‚É£ CAPTURA NOME DO CONTATO AUTOMATICAMENTE
      const contactName = (message as any).contactName;
      if (contactName && !profile.nome) {
        console.log(`üìù Salvando nome do contato automaticamente: ${contactName}`);
        await this.memoryDB.updateProfile({ chatId, nome: contactName });
        profile.nome = contactName;

        // üîÑ Sincroniza com onboarding
        if (this.onboardingManager) {
          this.onboardingManager.syncWithProfile(chatId, profile);
        }
      }

      // üÜï 1.1Ô∏è‚É£ CARREGA CONTEXTO COMPLETO DO CLIENTE
      let fullContext = null;
      if (this.contextRetrieval) {
        try {
          fullContext = await this.contextRetrieval.getFullContext(chatId);
          console.log('\nüß† ========================================');
          console.log('üß† CONTEXTO RECUPERADO');
          console.log('üß† ========================================');
          console.log(`   Tutor: ${fullContext.tutor?.nome || 'Novo'}`);
          console.log(`   Pets: ${fullContext.pets.length}`);
          console.log(`   Cliente: ${fullContext.flags.clienteNovo ? 'NOVO' : 'RETORNANDO'}`);
          if (fullContext.flags.clienteVip) console.log('   ‚≠ê CLIENTE VIP');
          if (fullContext.flags.clienteInativo) console.log('   ‚ö†Ô∏è CLIENTE INATIVO');
          if (!fullContext.flags.onboardingCompleto) console.log('   üìù ONBOARDING PENDENTE');
          console.log('üß† ========================================\n');
        } catch (error) {
          console.warn('‚ö†Ô∏è Erro ao carregar contexto - continuando sem contexto:', error);
        }
      }

      // üÜï 1.2Ô∏è‚É£ ONBOARDING DESABILITADO - IA RESPONDE NATURALMENTE
      // IMPORTANTE: Onboarding for√ßado DESABILITADO para permitir conversas naturais
      // A IA vai coletar informa√ß√µes (nome, pet, etc) organicamente durante a conversa
      // As informa√ß√µes s√£o extra√≠das automaticamente pelo InformationExtractor

      /* ONBOARDING FOR√áADO - DESABILITADO
      if (this.onboardingManager && fullContext && !fullContext.flags.onboardingCompleto) {
        // ... c√≥digo de onboarding removido
      }
      */

      // A IA agora responde livremente e coleta dados naturalmente

      // üì∏ PROCESSA FOTO DO PET SE NECESS√ÅRIO
      // üîç DEBUG: Loga estrutura da mensagem para diagn√≥stico
      console.log('\nüîç ========================================');
      console.log('üîç DEBUG MENSAGEM RECEBIDA:');
      console.log('üîç message.type:', message.type);
      console.log('üîç message.hasMedia:', message.hasMedia);
      console.log('üîç message.media:', message.media ? 'EXISTS' : 'UNDEFINED');
      console.log('üîç message.mediaUrl:', message.mediaUrl);
      console.log('üîç message._data?.type:', message._data?.type);
      console.log('üîç ========================================\n');

      const hasPhoto = this.photoAnalyzer.hasPhoto(message);
      console.log(`üîç hasPhoto() retornou: ${hasPhoto}`);

      if (hasPhoto) {
        console.log('\nüì∏ ========================================');
        console.log('üì∏ FOTO DETECTADA - ANALISANDO PET');
        console.log('üì∏ ========================================\n');

        try {
          const photoUrl = this.photoAnalyzer.getPhotoUrl(message);
          console.log(`üîç photoUrl extra√≠da: ${photoUrl}`);

          if (!photoUrl) {
            throw new Error('URL da foto n√£o encontrada');
          }

          // Analisa a foto com Vision API
          const analysis = await this.photoAnalyzer.analyzePetPhoto(photoUrl);

          if (analysis.detected && analysis.confidence > 50) {
            console.log(`‚úÖ Pet detectado: ${analysis.petType} (${analysis.confidence}% confian√ßa)`);
            console.log(`üìù Ra√ßa: ${analysis.breed}, Porte: ${analysis.size}, Idade: ${analysis.age}`);

            // Atualiza perfil automaticamente
            if (analysis.petType && !profile.petTipo) {
              this.memoryDB.updateProfile({ chatId, petTipo: analysis.petType });
              profile.petTipo = analysis.petType;
              console.log(`‚úÖ Tipo salvo: ${analysis.petType}`);
            }

            if (analysis.breed && !profile.petRaca) {
              this.memoryDB.updateProfile({ chatId, petRaca: analysis.breed });
              profile.petRaca = analysis.breed;
              console.log(`‚úÖ Ra√ßa salva: ${analysis.breed}`);
            }

            if (analysis.size && !profile.petPorte) {
              this.memoryDB.updateProfile({ chatId, petPorte: analysis.size });
              profile.petPorte = analysis.size;
              console.log(`‚úÖ Porte salvo: ${analysis.size}`);
            }

            // Gera resposta humanizada sobre a foto
            const photoResponse = this.photoAnalyzer.generatePhotoResponse(analysis, profile.petNome);

            // Envia rea√ß√£o ‚ù§Ô∏è primeiro (conex√£o instant√¢nea)
            await this.wahaService.sendReaction(chatId, message.id || message._data?.id?.id || 'unknown', '‚ù§Ô∏è');
            await new Promise(resolve => setTimeout(resolve, 1500));

            // Envia resposta humanizada sobre a foto
            const typingTime = this.humanDelay.calculateAdaptiveTypingTime(photoResponse, 2000, new Date().getHours());
            await this.wahaService.sendHumanizedMessage(chatId, photoResponse, typingTime);

            // Marca como processado e sai (n√£o processa como mensagem de texto)
            this.processingMessages.delete(messageId);

            // Define presen√ßa offline ap√≥s delay
            setTimeout(async () => {
              await this.wahaService.setPresence(chatId, false);
            }, 25000);

            return;
          } else {
            console.log(`‚ö†Ô∏è Pet n√£o detectado ou baixa confian√ßa (${analysis.confidence}%)`);
          }
        } catch (error: any) {
          console.error('\n‚ùå ========================================');
          console.error('‚ùå ERRO AO PROCESSAR FOTO:');
          console.error(`‚ùå Mensagem: ${error.message}`);
          console.error(`‚ùå Stack: ${error.stack}`);
          console.error('‚ùå ========================================\n');
          // Continua processamento normal se falhar
        }
      } else {
        // Log quando n√£o detecta foto (para debug)
        if (message.body && message.body.length < 50) {
          console.log(`üîç Mensagem SEM foto: "${message.body}"`);
        }
      }

      // 2Ô∏è‚É£ CALCULA TEMPO DE RESPOSTA (engajamento)
      const lastTimestamp = this.lastMessageTimestamps.get(chatId) || now;
      const responseTime = now - lastTimestamp;
      this.lastMessageTimestamps.set(chatId, now);

      console.log(`‚è±Ô∏è  Tempo de resposta: ${Math.round(responseTime / 1000)}s`);

      // 3Ô∏è‚É£ AN√ÅLISE DE ENGAJAMENTO
      const engagement = this.engagementAnalyzer.analyzeEngagement(profile, responseTime);
      console.log(`üìä Engajamento: ${engagement.level} (score: ${engagement.score})`);
      console.log(`üéØ Padr√£o: ${engagement.pattern}`);
      console.log(`üí° Sinais de compra: ${engagement.buyingSignals.join(', ') || 'nenhum'}`);

      // 4Ô∏è‚É£ AN√ÅLISE DE SENTIMENTO
      const sentiment = this.sentimentAnalyzer.analyze(body);
      console.log(`üòä Sentimento: ${sentiment.type} (${Math.round(sentiment.confidence * 100)}%)`);

      // 5Ô∏è‚É£ CONTEXTO (hora do dia, energia)
      const context = this.contextAwareness.getContext();
      console.log(`üåÖ Contexto: ${context.greeting}, energia ${context.energyLevel}`);

      // 6Ô∏è‚É£ AJUSTA TOM BASEADO NO CONTEXTO (evita festivo √† noite, etc)
      const adjustedTone = this.contextAwareness.adjustToneByContext(sentiment.suggestedTone, context);
      console.log(`üé≠ Tom: ${sentiment.suggestedTone} ‚Üí ${adjustedTone} (ajustado)`);

      // 7Ô∏è‚É£ EXTRAI INFORMA√á√ïES (nome do pet, tipo, ra√ßa, problema)
      const extractedInfo = this.informationExtractor.extract(body);
      const hasExtractedInfo = this.informationExtractor.hasInfo(extractedInfo);
      if (hasExtractedInfo) {
        console.log(`üìù Informa√ß√µes extra√≠das:`, extractedInfo);

        // Atualiza perfil com informa√ß√µes extra√≠das
        if (extractedInfo.petName && !profile.petNome) {
          this.memoryDB.updateProfile({ chatId, petNome: extractedInfo.petName });
          profile.petNome = extractedInfo.petName;
        }
        if (extractedInfo.petType && !profile.petTipo) {
          this.memoryDB.updateProfile({ chatId, petTipo: extractedInfo.petType });
          profile.petTipo = extractedInfo.petType;
        }
        if (extractedInfo.breed && !profile.petRaca) {
          this.memoryDB.updateProfile({ chatId, petRaca: extractedInfo.breed });
          profile.petRaca = extractedInfo.breed;
        }

        // üîÑ SINCRONIZA com onboarding (evita perguntar de novo)
        if (this.onboardingManager) {
          this.onboardingManager.syncWithProfile(chatId, profile);
        }
      }

      // üÜï 8Ô∏è‚É£ AN√ÅLISE PSICOL√ìGICA PROFUNDA
      console.log('\nüé≠ ========================================');
      console.log('üé≠ AN√ÅLISE PSICOL√ìGICA INICIADA');
      console.log('üé≠ ========================================\n');

      // Detecta dimens√µes psicol√≥gicas
      const personalityDimensions = this.personalityDetector.analyze(body, profile, responseTime);
      const dominantTraits = this.personalityDetector.getDominantTraits(personalityDimensions);
      console.log(`üéØ Dimens√µes psicol√≥gicas detectadas:`);
      console.log(`   Tra√ßos dominantes (>70): ${dominantTraits.join(', ') || 'equilibrado'}`);

      // Classifica em arqu√©tipo
      const personalityDimensionsRefined = this.personalityDetector.refineWithHistory(personalityDimensions, profile);
      const personalityProfile = this.personalityProfiler.classify(personalityDimensionsRefined);
      console.log(`\nüé≠ ARQU√âTIPO: ${personalityProfile.archetype.toUpperCase()}`);
      console.log(`   Confian√ßa: ${personalityProfile.confidence}%`);
      console.log(`   Tom recomendado: ${personalityProfile.communicationPreferences.tone}`);
      console.log(`   Velocidade: ${personalityProfile.communicationPreferences.responseSpeed}`);
      console.log(`   Detalhamento: ${personalityProfile.communicationPreferences.detailLevel}`);

      // An√°lise emocional avan√ßada (15 emo√ß√µes)
      const emotionalAnalysis = this.emotionalIntelligence.analyze(body, {
        previousSentiment: profile.lastSentiment,
        urgency: sentiment.type === 'urgente' ? 'alta' : 'normal',
        engagementScore: engagement.score
      });
      console.log(`\nüí≠ EMO√á√ÉO: ${emotionalAnalysis.primaryEmotion} (${emotionalAnalysis.intensity}%)`);
      if (emotionalAnalysis.secondaryEmotion) {
        console.log(`   Emo√ß√£o secund√°ria: ${emotionalAnalysis.secondaryEmotion}`);
      }
      console.log(`   Tom emocional: ${emotionalAnalysis.recommendedResponse.tone}`);
      console.log(`   Valida√ß√£o necess√°ria: ${emotionalAnalysis.recommendedResponse.validation ? 'SIM' : 'N√ÉO'}`);

      // üìä PERSISTE AN√ÅLISE EMOCIONAL (para hist√≥rico rastre√°vel)
      const emotionalPersistence = getEmotionalPersistence();
      (async () => {
        try {
          await emotionalPersistence.saveEmotionalAnalysis({
            tutorId: (profile as any).tutorId || chatId, // TODO: Adicionar tutorId ao UserProfile
            chatId,
            emocaoPrimaria: emotionalAnalysis.primaryEmotion,
            emocaoSecundaria: emotionalAnalysis.secondaryEmotion,
            intensidadeEmocional: emotionalAnalysis.intensity,
            sentimentoPredominante: sentiment?.type,
            tomConversacao: emotionalAnalysis.recommendedResponse.tone,
            engagementScore: engagement.score,
            engagementLevel: engagement.level,
            sinaisCompra: engagement.buyingSignals || [],
            arquetipo: personalityProfile.archetype,
            dimensoesPersonalidade: personalityProfile.dimensions as any,
            contextoConversa: body.substring(0, 200) // Primeiros 200 chars
          });
        } catch (error) {
          // N√£o trava fluxo se falhar
          console.error('Erro ao salvar an√°lise emocional:', error);
        }
      })();

      // An√°lise de fluxo de conversa√ß√£o
      const flowAnalysis = this.flowOptimizer.identifyStage(body, profile, personalityProfile.archetype);
      console.log(`\nüó∫Ô∏è JORNADA: ${flowAnalysis.currentStage.toUpperCase()} ‚Üí ${flowAnalysis.nextStage}`);
      console.log(`   Pronto para avan√ßar: ${flowAnalysis.readyToAdvance ? 'SIM' : 'N√ÉO'}`);
      console.log(`   Pr√≥xima a√ß√£o: ${this.flowOptimizer.suggestNextAction(flowAnalysis, personalityProfile.archetype)}`);

      // Avisos importantes
      if (personalityProfile.warnings.length > 0) {
        console.log(`\n‚ö†Ô∏è AVISOS:`);
        personalityProfile.warnings.forEach(w => console.log(`   ${w}`));
      }

      console.log('\nüé≠ ========================================');
      console.log('üé≠ AN√ÅLISE PSICOL√ìGICA CONCLU√çDA');
      console.log('üé≠ ========================================\n');

      // üÜï 8.5Ô∏è‚É£ AN√ÅLISE DE INTEN√á√ÉO E JORNADA
      let intentAnalysis = null;
      let journeyAnalysis = null;

      if (this.intentAnalyzer) {
        try {
          intentAnalysis = this.intentAnalyzer.analyzeIntent(body, profile);
          journeyAnalysis = this.intentAnalyzer.analyzeJourney(profile);

          console.log('\nüéØ ========================================');
          console.log('üéØ AN√ÅLISE DE INTEN√á√ÉO E JORNADA');
          console.log('üéØ ========================================');
          console.log(`   Inten√ß√£o: ${intentAnalysis.intent} (${intentAnalysis.confidence}%)`);
          console.log(`   Urg√™ncia: ${intentAnalysis.urgency.toUpperCase()}`);
          console.log(`   Jornada: ${journeyAnalysis.currentStage} ‚Üí ${journeyAnalysis.nextStage}`);
          console.log(`   Pronto para avan√ßar: ${journeyAnalysis.readyToAdvance ? 'SIM' : 'N√ÉO'}`);
          if (intentAnalysis.suggestedAction) {
            console.log(`   üí° A√ß√£o: ${intentAnalysis.suggestedAction}`);
          }
          if (journeyAnalysis.blockers.length > 0) {
            console.log(`   ‚ö†Ô∏è Bloqueios: ${journeyAnalysis.blockers.join(', ')}`);
          }
          console.log('üéØ ========================================\n');

          // üìç A√á√ÉO AUTOM√ÅTICA: Enviar localiza√ß√£o se detectou inten√ß√£o
          if (intentAnalysis.intent === CustomerIntent.INFORMACAO_LOCALIZACAO) {
            console.log('\nüìç ========================================');
            console.log('üìç INTEN√á√ÉO DE LOCALIZA√á√ÉO DETECTADA');
            console.log('üìç Enviando localiza√ß√£o do petshop...');
            console.log('üìç ========================================\n');

            try {
              await this.wahaService.sendLocation(
                chatId,
                PETSHOP_CONFIG.endereco.latitude,
                PETSHOP_CONFIG.endereco.longitude,
                PETSHOP_CONFIG.nome,
                PETSHOP_CONFIG.endereco.completo
              );
              console.log('‚úÖ Localiza√ß√£o enviada com sucesso!');
            } catch (error) {
              console.error('‚ùå Erro ao enviar localiza√ß√£o:', error);
            }
          }
        } catch (error) {
          console.warn('‚ö†Ô∏è Erro na an√°lise de inten√ß√£o:', error);
        }
      }

      // 9Ô∏è‚É£ DECIS√ÉO DE REA√á√ÉO (antes de processar resposta)
      const reactionDecision = this.reactionDecider.decide(message, sentiment.type, hasExtractedInfo);
      if (reactionDecision.shouldReact) {
        console.log(`‚ù§Ô∏è Decis√£o de rea√ß√£o: ${reactionDecision.emoji} (reactOnly: ${reactionDecision.reactOnly})`);

        // Delay humanizado antes de reagir
        await new Promise(resolve => setTimeout(resolve, reactionDecision.delayMs));

        // Envia rea√ß√£o
        await this.wahaService.sendReaction(chatId, message.id || message._data?.id?.id || 'unknown', reactionDecision.emoji!);

        // Se √© s√≥ rea√ß√£o (sem texto), finaliza processamento aqui
        if (reactionDecision.reactOnly) {
          console.log('‚úÖ Rea√ß√£o enviada (sem texto). Finalizando...\n');

          // Define presen√ßa como OFFLINE ap√≥s delay
          setTimeout(async () => {
            await this.wahaService.setPresence(chatId, false);
          }, 30000); // 30s depois

          this.processingMessages.delete(messageId);
          return;
        }
      }

      // 9Ô∏è‚É£ ATUALIZA PERFIL NO BANCO
      await this.memoryDB.addResponseTime(chatId, responseTime);
      profile.lastMessageTimestamp = now;
      profile.totalMessages += 1;
      profile.engagementScore = engagement.score;
      profile.engagementLevel = engagement.level;
      profile.lastSentiment = sentiment.type;

      this.memoryDB.updateProfile({
        chatId,
        lastMessageTimestamp: now,
        totalMessages: profile.totalMessages,
        engagementScore: engagement.score,
        engagementLevel: engagement.level,
        lastSentiment: sentiment.type
      });

      // üîü SALVA MENSAGEM NO HIST√ìRICO (com messageId para cita√ß√µes)
      const whatsappMessageId = message.id || message._data?.id?.id || null;
      await this.memoryDB.saveMessage(chatId, 'user', body, sentiment.type, engagement.score, whatsappMessageId);

      // 1Ô∏è‚É£1Ô∏è‚É£ DELAY E MARCA COMO LIDA (refinado por urg√™ncia)
      let readDelay = 3000; // Padr√£o: 3s
      if (sentiment.type === 'urgente') {
        readDelay = 1000; // Urgente: 1s
      } else if (context.energyLevel === 'baixa') {
        readDelay = 5000; // Noite: 5s
      }

      await new Promise(resolve => setTimeout(resolve, readDelay));
      await this.wahaService.markAsRead(chatId);

      //üîü GERA RESPOSTA COM CONTEXTO COMPORTAMENTAL + PSICOL√ìGICO + CONTEXTO COMPLETO
      console.log('ü§ñ Gerando resposta com IA comportamental + psicol√≥gica + contexto completo...');

      // ‚ö° SPRINT 1: Verifica se deve usar SAUDA√á√ÉO PERSONALIZADA
      const personalizedGreeting = this.personalizedGreeting.generateGreeting(fullContext, profile, body);
      if (personalizedGreeting) {
        console.log(`‚ö° SAUDA√á√ÉO PERSONALIZADA detectada: "${personalizedGreeting}"`);
        // Usa sauda√ß√£o personalizada ao inv√©s da IA
        // Continua fluxo normal depois
      }

      // Formata contexto completo para o prompt
      let contextPrompt = '';
      if (fullContext && this.contextRetrieval) {
        try {
          contextPrompt = this.contextRetrieval.formatContextForPrompt(fullContext);
        } catch (error) {
          console.warn('‚ö†Ô∏è Erro ao formatar contexto:', error);
        }
      }

      // Se tem sauda√ß√£o personalizada, usa ela. Sen√£o, gera com IA
      const response = personalizedGreeting || await this.openaiService.generateResponse(chatId, body, {
        engagementScore: engagement.score,
        sentiment: sentiment.type,
        urgency: sentiment.type === 'urgente' ? 'alta' : 'normal',
        petName: profile.petNome,
        userName: profile.nome,
        // Contexto psicol√≥gico profundo
        archetype: personalityProfile.archetype,
        emotion: emotionalAnalysis.primaryEmotion,
        emotionIntensity: emotionalAnalysis.intensity,
        conversationStage: flowAnalysis.currentStage,
        needsValidation: emotionalAnalysis.recommendedResponse.validation,
        // üÜï CONTEXTO COMPLETO CROSS-SESSION
        fullContext: contextPrompt,
        intent: intentAnalysis?.intent,
        journeyStage: journeyAnalysis?.currentStage,
        isNewClient: fullContext?.flags.clienteNovo,
        isVipClient: fullContext?.flags.clienteVip,
        isInactive: fullContext?.flags.clienteInativo
      });

      // 1Ô∏è‚É£1Ô∏è‚É£ AN√ÅLISE DE CONVERS√ÉO
      const conversionOpp = this.conversionOptimizer.detectOpportunity(profile, engagement);
      if (conversionOpp) {
        console.log(`üí∞ Oportunidade de convers√£o detectada! Score: ${conversionOpp.score}`);
        console.log(`üìà A√ß√£o: ${conversionOpp.suggestedAction}`);
        await this.memoryDB.saveConversionOpportunity({ chatId, ...conversionOpp });
      }

      // ‚ö° SPRINT 1: PROVA SOCIAL (se cliente demonstrou interesse)
      if (intentAnalysis && journeyAnalysis) {
        const shouldSendProof = this.proofSocialEngine.shouldSendProof(
          intentAnalysis.intent,
          journeyAnalysis.currentStage
        );

        if (shouldSendProof) {
          const detectedService = this.proofSocialEngine.detectServiceFromMessage(body);
          if (detectedService) {
            console.log(`üì∏ Detectado interesse em: ${detectedService} - Enviando prova social`);

            // Envia prova social (n√£o bloqueia fluxo)
            this.proofSocialEngine.sendProof(chatId, detectedService, 'stat-only').catch(error => {
              console.warn('‚ö†Ô∏è Erro ao enviar prova social:', error);
            });
          }
        }
      }

      // üí≥ OFERTA DE DESCONTO PIX (se habilitado e detectado inten√ß√£o de compra)
      if (this.pixDiscountManager?.shouldOfferPixDiscount(body, profile)) {
        console.log('\nüí≥ ========================================');
        console.log('üí≥ INTEN√á√ÉO DE COMPRA DETECTADA');
        console.log('üí≥ Preparando oferta de desconto PIX...');
        console.log('üí≥ ========================================\n');

        // Aqui voc√™ pode customizar os itens baseado no contexto da conversa
        // Por exemplo, extrair do response da IA ou do hist√≥rico
        // Por enquanto, vamos usar um exemplo gen√©rico que voc√™ pode ajustar

        // EXEMPLO: Detecta valor mencionado na mensagem
        const extractedValue = this.pixDiscountManager.extractValueFromMessage(body);

        if (extractedValue && extractedValue > 0) {
          // Cria oferta de desconto
          const offer = this.pixDiscountManager.createPixOffer([{
            name: 'Produto/Servi√ßo',
            value: extractedValue
          }]);

          // Gera mensagem de oferta
          const offerMessage = this.pixDiscountManager.formatOfferMessage(offer, profile.nome);

          // Salva oferta pendente
          this.pixDiscountManager.savePendingOffer(chatId, offer);

          // Envia oferta de desconto
          await this.wahaService.sendMessage(chatId, offerMessage);
          console.log(`üí≥ Oferta enviada: 10% desconto (${extractedValue} ‚Üí ${offer.finalValue})`);

          // Finaliza processamento (n√£o envia resposta da IA)
          this.processingMessages.delete(messageId);
          setTimeout(async () => {
            await this.wahaService.setPresence(chatId, false);
          }, 30000);

          return; // IMPORTANTE: Para processamento aqui
        } else {
          // Se n√£o detectou valor, apenas loga e continua com resposta normal
          console.log('üí° Inten√ß√£o de compra detectada mas sem valor espec√≠fico - continuando com resposta normal');
        }
      }

      // Se cliente confirmar desconto PIX ("sim", "quero", "pode mandar")
      if (this.pixDiscountManager?.hasPendingOffer(chatId)) {
        const confirmationSignals = ['sim', 'quero', 'pode', 'manda', 'fecha', 'beleza', 'ok'];
        const hasConfirmation = confirmationSignals.some(signal => body.toLowerCase().includes(signal));

        if (hasConfirmation) {
          console.log('\nüí≥ ========================================');
          console.log('üí≥ CLIENTE CONFIRMOU DESCONTO PIX');
          console.log('üí≥ Gerando cobran√ßa no Asaas...');
          console.log('üí≥ ========================================\n');

          const pendingOffer = this.pixDiscountManager.getPendingOffer(chatId);
          if (pendingOffer) {
            try {
              const { payment, message: pixMessage } = await this.pixDiscountManager.generatePixPayment(
                chatId,
                profile,
                pendingOffer
              );

              // Envia link de pagamento
              await this.wahaService.sendMessage(chatId, pixMessage);
              console.log(`üí≥ Link PIX enviado: ${payment.invoiceUrl}`);

              // Finaliza processamento
              this.processingMessages.delete(messageId);
              setTimeout(async () => {
                await this.wahaService.setPresence(chatId, false);
              }, 30000);

              return; // IMPORTANTE: Para processamento aqui
            } catch (error: any) {
              console.error('‚ùå Erro ao gerar pagamento:', error.message);
              // Continua com resposta normal em caso de erro
            }
          }
        }
      }

      // 1Ô∏è‚É£2Ô∏è‚É£ APLICA IMPERFEI√á√ïES HUMANAS (2% chance)
      const imperfection = this.imperfectionEngine.processText(response);
      let finalResponse = imperfection.shouldApply && imperfection.modifiedText
        ? imperfection.modifiedText
        : response;

      // üéØ VALIDA√á√ÉO DE RELEV√ÇNCIA: Garante que resposta √© √∫til
      const relevanceValidation = ResponseRelevanceValidator.validate(body, finalResponse);

      if (!relevanceValidation.isRelevant) {
        console.warn(`‚ö†Ô∏è Resposta com baixa relev√¢ncia detectada (${relevanceValidation.confidence}%)`);
        console.warn(`   Motivo: ${relevanceValidation.reason}`);

        if (relevanceValidation.suggestions) {
          console.warn(`   Sugest√µes: ${relevanceValidation.suggestions.join(', ')}`);
        }

        // Se confian√ßa muito baixa (<40%), tenta regenerar resposta mais direta
        if (relevanceValidation.confidence < 40) {
          console.log(`üîÑ Regenerando resposta mais direta...`);

          // For√ßa resposta mais direta adicionando contexto ao prompt
          const directPrompt = `${body}\n\nIMPORTANTE: Responda de forma DIRETA e OBJETIVA. Se for pergunta sobre pre√ßo/hor√°rio/local, d√™ a informa√ß√£o EXATA.`;

          try {
            // For√ßa resposta direta sem regenerar (evita chamada extra)
            // TODO: Melhorar sistema de regenera√ß√£o quando necess√°rio
            console.warn(`‚ö†Ô∏è Mantendo resposta original (regenera√ß√£o desabilitada)`);
          } catch (error) {
            console.warn(`Erro ao validar resposta:`, error);
          }
        }
      } else {
        console.log(`‚úÖ Resposta relevante (${relevanceValidation.confidence}% confian√ßa)`);
      }

      // üîç AUDITORIA: Verifica e corrige padr√µes rob√≥ticos
      const auditResult = MessageAuditor.audit(finalResponse);
      MessageAuditor.logAudit(chatId, finalResponse, auditResult);

      if (!auditResult.isHuman) {
        console.log(`‚ö†Ô∏è Mensagem rob√≥tica detectada (score: ${auditResult.score}/100)`);
        console.log(`üîß Aplicando ${auditResult.patterns.length} corre√ß√µes autom√°ticas...`);
        finalResponse = MessageAuditor.suggest(finalResponse, auditResult);

        // Re-audita ap√≥s corre√ß√£o
        const reAudit = MessageAuditor.audit(finalResponse);
        console.log(`‚úÖ Mensagem corrigida (novo score: ${reAudit.score}/100)`);
      }

      // üìä FEEDBACK LOOP: Salva qualidade da resposta para aprendizado
      const qualityTracker = getQualityTracker();
      const endTime = Date.now();

      (async () => {
        try {
          await qualityTracker.trackResponse({
            chatId,
            tutorId: (profile as any)?.tutorId || undefined,
            userMessage: body,
            botResponse: finalResponse,
            qualityScore: auditResult.score,
            passedValidation: auditResult.isHuman,
            rejectionReason: !auditResult.isHuman ? auditResult.patterns.join(', ') : undefined,
            modeUsed: undefined, // TODO: capturar selectedMode
            pipelineUsed: 'legacy', // TODO: detectar pipeline V2 quando usar
            sentimentDetected: sentiment?.type,
            intentDetected: undefined, // TODO: capturar intent
            responseTimeMs: endTime - startTime,
            usedRag: false, // TODO: detectar quando RAG for usado
            validationsApplied: ['MessageAuditor', 'HumanImperfection'],
            validationScores: {
              humanness: auditResult.score,
              imperfection: imperfection.shouldApply ? 100 : 0
            },
            needsReview: auditResult.score < 60
          });
        } catch (error) {
          // N√£o trava fluxo se falhar
          console.error('Erro ao salvar qualidade:', error);
        }
      })();

      // 1Ô∏è‚É£3Ô∏è‚É£ AN√ÅLISE DE CITA√á√ÉO CONTEXTUAL
      // üß† MEM√ìRIA EXPANDIDA: Busca √∫ltimas 50 mensagens para cita√ß√µes contextuais
      const conversationHistory = await this.memoryDB.getRecentMessagesWithIds(chatId, 50);
      let quoteDecision = this.quoteAnalyzer.analyze(body, conversationHistory, extractedInfo);
      quoteDecision = this.quoteAnalyzer.shouldApplyRandomly(quoteDecision); // 70% chance

      if (quoteDecision.shouldQuote) {
        console.log(`üí¨ Cita√ß√£o detectada: ${quoteDecision.reason}`);
        console.log(`üí¨ MessageId a citar: ${quoteDecision.messageIdToQuote?.substring(0, 15)}...`);
      }

      // 1Ô∏è‚É£4Ô∏è‚É£ QUEBRA EM M√öLTIPLAS MENSAGENS SE NECESS√ÅRIO
      const shouldSplit = this.responseSplitter.shouldSplit(finalResponse);

      if (shouldSplit) {
        console.log('üìù Resposta longa - quebrando em m√∫ltiplas mensagens');
        const split = this.responseSplitter.split(finalResponse);

        for (let i = 0; i < split.parts.length; i++) {
          const part = split.parts[i];
          const delay = split.delays[i];

          // Delay antes de cada parte
          await new Promise(resolve => setTimeout(resolve, delay));

          // Calcula typing time adaptativo
          const typingTime = this.humanDelay.calculateAdaptiveTypingTime(
            part,
            responseTime,
            context.hourOfDay
          );

          console.log(`üì§ Enviando parte ${i + 1}/${split.parts.length}`);

          // Cita apenas na primeira parte (se aplic√°vel)
          if (i === 0 && quoteDecision.shouldQuote && quoteDecision.messageIdToQuote) {
            await this.wahaService.sendHumanizedQuotedMessage(chatId, part, typingTime, quoteDecision.messageIdToQuote);
          } else {
            await this.wahaService.sendHumanizedMessage(chatId, part, typingTime);
          }
        }

        // üí¨ MARCA CONVERSA COMO ATIVA ap√≥s enviar todas as partes
        this.conversationState.markActive(chatId);
      } else {
        // 1Ô∏è‚É£5Ô∏è‚É£ CALCULA DELAYS HUMANIZADOS ADAPTATIVOS
        const readingTime = this.humanDelay.calculateReadingTime(body);
        const typingTime = this.humanDelay.calculateAdaptiveTypingTime(
          finalResponse,
          responseTime,
          context.hourOfDay
        );

        console.log(`‚è±Ô∏è Tempo de leitura: ${Math.round(readingTime / 1000)}s`);
        console.log(`‚è±Ô∏è Tempo de digita√ß√£o: ${Math.round(typingTime / 1000)}s (adaptativo!)`);

        // 1Ô∏è‚É£6Ô∏è‚É£ SIMULA LEITURA
        await new Promise(resolve => setTimeout(resolve, readingTime));

        // 1Ô∏è‚É£7Ô∏è‚É£ ENVIA COM INDICADOR DE DIGITA√á√ÉO (com ou sem cita√ß√£o)
        console.log('‚å®Ô∏è Iniciando digita√ß√£o...');
        if (quoteDecision.shouldQuote && quoteDecision.messageIdToQuote) {
          await this.wahaService.sendHumanizedQuotedMessage(chatId, finalResponse, typingTime, quoteDecision.messageIdToQuote);
        } else {
          await this.wahaService.sendHumanizedMessage(chatId, finalResponse, typingTime);
        }
      }

      // üí¨ MARCA CONVERSA COMO ATIVA (evita InstantAck nas pr√≥ximas mensagens)
      this.conversationState.markActive(chatId);

      // 1Ô∏è‚É£8Ô∏è‚É£ SALVA RESPOSTA NO HIST√ìRICO
      await this.memoryDB.saveMessage(chatId, 'assistant', finalResponse);

      // 1Ô∏è‚É£9Ô∏è‚É£ üß† INICIA NEURO-FOLLOWUPS SE NECESS√ÅRIO
      if (this.immediateFollowUpManager.shouldStartFollowUps(profile)) {
        // Passa arqu√©tipo detectado
        this.immediateFollowUpManager.startFollowUpSequence(
          chatId,
          profile,
          personalityProfile.archetype // Arqu√©tipo psicol√≥gico
        );
        console.log(`üß† NEURO-followups INICIADOS (7 n√≠veis em 30min com ${personalityProfile.archetype})`);
      }

      // 2Ô∏è‚É£0Ô∏è‚É£ DEFINE PRESEN√áA COMO OFFLINE (ap√≥s delay humanizado)
      const offlineDelay = Math.random() * 20000 + 15000; // 15-35s
      setTimeout(async () => {
        await this.wahaService.setPresence(chatId, false);
      }, offlineDelay);

      console.log('\n‚úÖ ========================================');
      console.log('‚úÖ PROCESSAMENTO CONCLU√çDO COM SUCESSO!');
      console.log(`‚úÖ Resposta enviada: "${finalResponse.substring(0, 80)}..."`);
      console.log(`‚úÖ Presen√ßa ser√° definida como OFFLINE em ${Math.round(offlineDelay / 1000)}s`);
      console.log('‚úÖ ========================================\n');

      this.processingMessages.delete(messageId);
    } catch (error) {
      console.error('‚ùå Erro ao processar mensagem:', error);
      const messageId = `${message.from}-${message.timestamp}`;
      this.processingMessages.delete(messageId);
    }
  }

  public getStats(): {
    processing: number;
    messageBuffer: { activeBuffers: number; totalMessages: number };
  } {
    return {
      processing: this.processingMessages.size,
      messageBuffer: this.messageBuffer.getStats(),
    };
  }
}
